---
title: 'JSX 解析'
description: JSX 仅仅只是 React.createElement(component, props, ...children) 函数的语法糖。createElement 进行一系列有效性检查，调用 ReactElement，返回一个 element 对象。
author: c0ka
author_url: https://github.com/c0ka
author_image_url: https://github.com/c0ka.png
image:
thumb: 
tags:
  - react
  - programming
date: '2021-02-07'
toc_depth: 3
---

JSX 仅仅只是 `React.createElement(component, props, ...children)` 函数的语法糖。
createElement 进行一系列有效性检查，调用 ReactElement，返回一个 element 对象。

```javascript
return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);

var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner，
    _store: {}, // 有一个不可枚举的 validated 属性
    _self,  // 这两个是 DEV 环境下的
    _source
  };
```

### 使用 JSX 的语法

```javascript
function Layout({children}) {
  return <div className="layout-component">{children}</div>
}

function Hi(props) {
  return <div>Hi {props.name}, my buddy!</div>;
}

const App = () => {
	return (
  	 <Layout>
      <div>try this</div>
      <Hi name="julian"/>
     </Layout>)
}
```

### Babel 转译输出结果
函数式组件就是普通的 js 函数，接受 props（对象） 参数。 
props 参数在函数返回的 React 元素中使用时，也是createElement函数调用的 children参数的一部分。

使用组件就是函数调用，
props.children 是组件被调用时传入的子组件。

```javascript
function Layout({
  children
}) {
  return /*#__PURE__*/React.createElement("div", {
    className: "layout-component"
  }, children);
}

function Hi(props) {
  return /*#__PURE__*/React.createElement("div", null, "Hi ", props.name, ", my buddy!");
}

const App = () => {
  return /*#__PURE__*/React.createElement(
      Layout, 
      null, 
      /*#__PURE__*/React.createElement("div", null, "try this"), 
      /*#__PURE__*/React.createElement(Hi, {name: "julian"})
  );
};
```

### React.createElement 源码
```javascript
/**
   * Create and return a new ReactElement of the given type.
   * See https://reactjs.org/docs/react-api.html#createelement
   */

  function createElement(type, config, children) {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null;
    var self = null;
    var source = null;

    if (config != null) {
      if (hasValidRef(config)) {
        ref = config.ref;

        {
          warnIfStringRefCannotBeAutoConverted(config);
        }
      }

      if (hasValidKey(config)) {
        key = '' + config.key;
      }

      self = config.__self === undefined ? null : config.__self;
      source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

      for (propName in config) {
        if (hasOwnProperty$1.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
          props[propName] = config[propName];
        }
      }
    } // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.


    var childrenLength = arguments.length - 2;

    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 2];
      }

      {
        if (Object.freeze) {
          Object.freeze(childArray);
        }
      }

      props.children = childArray;
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    {
      if (key || ref) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }

        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
```
### ReactElement 源码
```javascript 
/**
   * Factory method to create a new React element. This no longer adheres to
   * the class pattern, so do not use new to call it. Also, instanceof check
   * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
   * if something is a React Element.
   *
   * @param {*} type
   * @param {*} props
   * @param {*} key
   * @param {string|object} ref
   * @param {*} owner
   * @param {*} self A *temporary* helper to detect places where `this` is
   * different from the `owner` when React.createElement is called, so that we
   * can warn. We want to get rid of owner and replace string `ref`s with arrow
   * functions, and as long as `this` and owner are the same, there will be no
   * change in behavior.
   * @param {*} source An annotation object (added by a transpiler or otherwise)
   * indicating filename, line number, and/or other information.
   * @internal
   */


  var ReactElement = function (type, key, ref, self, source, owner, props) {
    var element = {
      // This tag allows us to uniquely identify this as a React Element
      $$typeof: REACT_ELEMENT_TYPE,
      // Built-in properties that belong on the element
      type: type,
      key: key,
      ref: ref,
      props: props,
      // Record the component responsible for creating this element.
      _owner: owner
    };

    {
      // The validation flag is currently mutative. We put it on
      // an external backing store so that we can freeze the whole object.
      // This can be replaced with a WeakMap once they are implemented in
      // commonly used development environments.
      element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
      // the validation flag non-enumerable (where possible, which should
      // include every environment we run tests in), so the test framework
      // ignores it.

      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }); // self and source are DEV only properties.

      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      }); // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.

      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });

      if (Object.freeze) {
        Object.freeze(element.props);
        Object.freeze(element);
      }
    }

    return element;
  };
  ```